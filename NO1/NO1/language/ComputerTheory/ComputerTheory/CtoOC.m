//
//  CtoOC.m
//  StudyChen
//
//  Created by xs on 2017/5/9.
//  Copyright © 2017年 Touker. All rights reserved.
//

#import "CtoOC.h" // C 到OC 转变  编码规范 http://leanote.com/s/58fd93b84202c86e23000001




@implementation CtoOC


@end
/*
 

 NSString  const * atr = @"abc";
 atr = @"axax";
 * atr = @"aa";
 
Objective-c中 isEqual ，isEqualToString ， == 三者的区别 http://www.jianshu.com/p/915356e280fc
 
 
1:OC 的学习
    1:学习其 从C ---> 到OC 这个包装的 语法过程
    2:学习其 各自框架 
 */



@implementation chen



- (void)text{
    void text3();

    text3();
}


@end



void text2(){
    chen *one = [chen new];
    [one text];

}

void text3(){
    text2();
}

/*
 
 OC 的本职 还是面向过程的 只不过是批了一成面向对象的 外衣，跟C 一样是弱语法,
        1:类跟方法 都可以只有 实现，没有声明【报警告，运行无问题】
        2:方法也可以只有声明，但运行时候才会检测【用了但无实现则崩溃】
 OC 的运行 原理【？？？？？？？？？？？？？？？？？？？？】动态性？

 
理论

【A1】类的声明:person
 1:类型的声明 @interface + 类名 ;在类名之后 + : 某类型 让其继承自此类，从而拥有其某些 属性 跟方法
 2:在 @interface 与 @end 之间用 {} 来声明其拥有的成员变量
 3:在 interface 与 @end 之间 {}之外 来声明其拥有的方法
 4:OC 跟 C 是使用的同一个编译器，要使用这个类 在使用之前必须有声明

【A2】类的实现
 1:通过 @implementation + 类名 来实现这个类
 2:在@implementation 与@end 之间来实现 之前声明的方法，OC 的方法可以只有 实现没有声明，但如果只有声明 没实现会报警告




【B1】成员变量

(1)成员变量的作用域 【直接访问形式_age】
    A:本类的属性在本类的对象方法中可以直接访问
    a:@private=====>私有的  只能在当前类的对象方法中访问，子类都不行，只能当前类
    b:@protected =====>受保护的 只能在当前类 和 子类 的对象方法中访问【默认】
    c:@package =====>本框架的类可以直接访问
    d:@public=====>公开的 【所有地方都可以通过对象访问】

(2)对外提供访问修改方法 【间接访问形式 【】】
    a:set方法  修改成员变量
    b:get方法  获取成员变量 【懒加载 的本质 只是利用get在这做了一层处理】
    c:.语法 是编译器特性，并不是直接访问成员变量，左后编译器还是将其转化为 set  get  方法的调用
    d:一个类只要对外提供了 set get 方法 在其他类或其子类中 都可以 访问修改【对外提供即在.h中有声明】【即在当前类所所导入的文件中有声明】

(3)成员变量的命名规范 【_age】
 a:为了跟get方法名 区分 成员变量名 以_下划线开头，这样也可以跟变量区分

(4) set get的简写
    a:@property int age; 此关键字会自动生成 其描述的 成员变量的 set get方法的声明
    b:@synthesize age = _age;自动生成 age 的 set get方法的声明的实现 ，并访问的是指定的 这个成员变量，如果没指定默认访问 age【如果没有则自动生成 且@private 性质的 】
    c:若自己同时重写了 set get 方法 则不会自动生成 带下划线的那个变量
(5)生成成员变量的自动生成
 @property: Xcode 4.4之后 定义一个 带下划线【私有的】的成员变量 且声明 实现其 set get 方法,如果自己有实现则不生成

(5)生成成员变量的修饰关键字
  。。。。。
 
 
 【C】方法
(1)方法的相关知识
 1:方法的声明实现:方法 可以只有声明,也可以只有实现;但前者比较危险
 2:在类的实现中 对象调用某个方法不需要想函数一样 使用之前必须声明
 

(2)方法 跟函数饿区别
 1:位置: 方法 的 声明，实现 只能写对应的位置，函数的声明 实现 位置 无要求，只有使用之前 声明就可以了
 2:调用者: 方法 只能有对象 或者类 调用，函数则可以直接调用
 3:相互:函数中可以创建对象，让对象调用自己的方法/方法中 也可以调用函数

(3)方法的本质
    1:方法也是一种数据类型，以 SEL类型指针存放方法的地址
    3:方法调用过程，先把方法名包装成一个SEL类型的数据，然后根据 SEL 去对应的地方找这个SEL所对应的方法地址，调用方法
 
 

 【D2】
 对象的创建【  [chen new]  】
 a:通过 [chen new] 来创建一个 新对象,返回一个 地址，
 b:OC 中 对象 的本质就是 结构体
 c:每个对象中 有个isa 指针 指向 自己的类对象【isa 是NSObject 的一个属性】

 指针保存对象 【 指针代表对象 】
 a:通过 一个 chen *someone  此类型的指针变量来保存此对象(地址)
 b:通过 someone = 另外一个对象 来修改此 指针变量所保存的地址对象
 c:创建了一个对象，但并没有指针 指向它，此时这个对象就匿名对象【匿名对象】

 指针对对象的访问【指针更改属性】
 a:通过指针来访问修改对象的成员变量;
 1:someone ->age (若不是在本类方法中想访问 要 加上 @public 关键字)
 2:someone.age

 指针给对象发消息【指针让对象 执行 事件】
 a:[a text] ,指针给对象发消息，让对象顺着自己的isa 指针 去调用 其类对象 中的方法

 对象调用类对象中的方法【对象自己做事情】
 a: -(void)text{};在方法中访问，访问，修改操作的是自己的成员变量 age  = 10;/
 b:OC 中 在运行中才会检测此对象有没有实现这个方法【动态检测】

 

 
 
  1:typedef struct objc_object *id;  【id = 对象】
  2:typedef struct objc_class *Class  【Class = 类对象】
  3:typedef struct objc_selector *SEL 【SEL = 一个方法】
 
 
 
 
 
 

 
 
 
 












 */
