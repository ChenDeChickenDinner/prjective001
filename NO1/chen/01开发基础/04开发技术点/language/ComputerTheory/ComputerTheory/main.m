//
//  main.m
//  ComputerTheory
//
//  Created by xs on 2017/5/9.
//  Copyright © 2017年 Touker. All rights reserved.
//

#import <Foundation/Foundation.h>
#import "CtoOC.h"
int main(int argc, const char * argv[]) {
    @autoreleasepool {

        chen *one  = [chen new];
        
        [one text];

    }
    return 0;
}


/*

 1:机器语言
 2:汇编语言（编程语言）
 3:高级语言（编程语言)
 1:编译型语言 -->程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。（程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言）
 2:解释型语言-->解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。在发布程序时，看起来省了道编译工序。但是，在运行程序的时候，解释性语言必须先解释再运行（一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等）

 词法分析 --> 语法分析 --> 语义检查和中间代码生成 --> 代码优化 -->目标代码生成
 编辑器(软件)--编译器(软件)--连接器(软件)--可执行程序

 预处理器:
 编译器:
 0:单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。
 1:前端-->主要负责解析输入的源代码，由语法分析器和语意分析器协同工作
 1:词法分析,将我们编写的文本代码流解析为一个一个的记号，分析得到的记号以供后续语法分析使用。
 2:语法分析,是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.
 2:后端-->编译器后端主要负责分析，优化中间代码,以及生成机器代码
 链接器:将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件。都提供静态链接和动态链接两种形式,


 进制:
 1：编程中默认显示的数字的是十进制的
 2：二进制(0b或者0B开头) 八进制(0开头) 十六进制(0x或者0X开头)
 int number = 12; (十进制)======> %d\%i 以带符号十进制形式输入整数  %u 不带符号
 int number2 = 0b1100;(二进制)
 int number3 = 014; (八进制) ======> %o 以带符号八进制形式输入整数 %#o 显示前导0
 int number4 = 0Xc、oxC;(十六进制) ======> %x 以带符号十六进制形式输入整数 %#x 显示前导0x
 3:n位二进制的取值范围 0~2的n次方-1

 内存：
 1：最小单位 1bit(位)  用bit来表示0 或 1
 2：字节 1字节 = 8bit  口口口口口口口口 八个位置
 3：内存
 1:内存中 以 每个字节为一存储单位，每个存储单位 有一个地址，计算机中义十六进制形表示内存单位的地址
 2:一个4G的内存 有多少个单位地址呢？4*1024 = 4096MB *1024 = 4194304KB *1024 = 4294967296个字节单位地址
 3:线性地址是一个32位无符号整数 0000 0000 00\ 00 0000 0000 \0000 0000 0001 [每一个32位的线性地址被划分为三部份，面目录索引(10位)：页表索引(10位)：偏移(12位)]将页的起始地址与线性地址中最后12位相加，得到最终我们想要的物理地址,可寻的最大地址为 2的32次方 = 4294967296个 = 4G也就是，高达4294967296个单元地址。每个单元地址 通常用十六进制数字表示，值的范围从0x00000000到0xffffffff）
 
 


 数据在内存的存储:
 a1:原码  如果机器字长为n，那么一个数的原码就是用一个n位的二进制数，其中最高位为符号位：正数为0，负数为1。剩下的n-1位表示概数的绝对值。
 a2:反码  在原码的基础上，符号位不变其他位按位取反(就是0变1，1变0)就可以了。
 a3:补码  在反码的基础上按照正常的加法运算加1
 a4:移码  将其补码的符号位取反即可

 b1:数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理，正数的补码就是其二进制数
 b2:一个有符号定点数的最高位为符号位，0是正，1是负；

 c 数值 5 --> （二进制数为101) --> (int 类型再内存中存储为 00000000 00000000 00000000 00000101
 
 


 内存的使用:
 1:在使用内存存储数据的时候，先根据数据类型分配对应的字节数，再取一个别名(常量，变量名)，最后初始化，若未初始化则此段数据不确定（定义变量，分配内存），类型决定此段内存能存储的数据范围
 2:内存分配 编译器按照内存地址递减的方式来给变量分配内存，且(数据的内存地址)为最小的那个字节的地址，但是数组中的元素（X1->X10)是从当前段内存的低-->到高 分配的
 3:内存的分区
 a: 代码区-->存放App代码；
 b: 常量区-->常量字符串就是放在这里；
 c: 全局区（静态区)-->全局变量(内，外部)就是放在这里，此处还分未初始化过 、初始化过； d: 代码区-->存放App代码；
 e: 堆区（heap） — 一般由程序员分配释放 ， 若程序员不释放，程序结束时可能由OS回收
 f: 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等
 注意: a,b,c 是程序一运行自动加载的



 
 + - * /  % 加减乘除取余二边必须都是整数，结果的正负性 只跟第一个数有关
 0:规则 从左到右 按照优先级 进行计算
 1:结果 -运算符二遍的数据类型应该为同一类型，且用相同类型变量接收
 01- 左边的运算（参与是什么类型则结果就是什么类型）若不同则进行自动类型提升
 int a = 1 + 1; double b = 5.2 + 4; 4-->4.0
 02- 右边的接收（若接收的类型与结果类型不一致则进行自动类型转换）
 double c = 10 / 3 ; 结果是3 ---->转变为3.000000
 03-若参与运算的数据不是想要的类型则可以进行强制类型转换（增加，丢失精度）

 a++,++a ，a--,--a   (变量自增自减)

 2: 赋值运算符 从右到左进行赋值
 int a = 3；int b = 3；（普通）
 a = b = 3;(连续赋值)
 a += 5; a -=2; （符合赋值运算符）a = a + 5;

 3：b  = a++, b = ++a (a最后总会+1，前者是在a自增之前就赋值给b,后者是a先自增再赋值给b)

 4：sizeof 计算 常量变量数据类型 的字节数  int 接收

 5：关系运算符（成立，不成立 结果为 0 / 1）表达式的值(只要有关系运算符参与的运算的结果 只有 0 / 1)
 1：<, >, ==, <=,  >=, !=

 6:逻辑运算符
 1：&&，||，！

 7:位运算符
 a:& 按位与 9&5   其实就是1001&101=1 (只有对应的两个二进位均为1时，结果位才为1，否则为0)
 b:| 按位或 9|5   其实就是1001|101=1101（只要对应的二个二进位有一个为1时，结果位就为1，否则为0）
 c:^ 按位异或 9^5 其实就是1001^101=1100 (当对应的二进位相异（不相同）时，结果为1，否则为0)
 d:~ 取反 ~5
 e:<< 左移 9<<3  = 9 * 2 的3次方
 f:>> 右移 9>>3  = 9 / 2 的3次方
*/
