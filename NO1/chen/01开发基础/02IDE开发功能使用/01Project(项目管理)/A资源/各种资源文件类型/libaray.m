/*
库：
1.是什么：是程序代码的集合
2.分类：
开源库：源代码是公开的，可以看到每个实现文件（.m文件）的实现 ===》(被别人使用)
闭源库：不公开源代码，是经过编译后的二进制文件，看不到具体的实现 ===》(被别人使用，但隐藏其实现部分)


闭源库：
1.从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。
2.库的组成依赖

3.库分静态库和动态库两种，是相对编译期和运行期的的角度来说的
静态库：在链接阶段，会将目标文件与静态库，一起链接打包到可执行文件中，如果多个程序用到，都会将其打包进自己的可执行文件中。程序运行阶段就不需要它了；
1.一起与目标文件打包==》造成可执行文件 偏大
2.谁用到谁就要将其 拷贝打包一份==>造成多次拷贝
3.被打进可执行文件中，运行则不需要它==》好处：不需要外部依赖，若库发生变化 则需要重新 编译

动态库：动态库把对一些库函数的链接载入推迟到程序运行的时期（公用一份，不用拷贝，节省空间，增量更新），但一旦链接期间找不到就会崩溃，没静态库安全



iOS中二进制文件形式
.a 是一个纯二进制文件，要有 .h 文件以及资源文件配合。
.framework 本身已经包含了.h和其它文件，可以直接使用

iOS中静态库和动态库的存在的形式
静态库：以.a  + 个人打的framework
动态库：以.tbd/.dylib +  系统的framework
 
 
 
静态库
0.形式 有二种，.a  跟Framework，在打包成.a文件的同时，还需要提供头文件，而Framework编译完成暴露的头文件都已经放好了。
1.打.a 静态库
 a:只打源码
 b:源码 + 对系统动态库的依赖
 c:源码 + 对三方库的依赖（.a/.framework），考虑三方库是否有 依赖。


动态库
0.Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式
3.主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉
1.动态库在制作的时候可以直接包含静态库，也能自动link所需要的依赖库。
2.唯一需要注意的是在导入自己制作的动态库时，需要在Embedded Binaries中导入，不然会报错：image not found。此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做Embedded Framework


Headers
包含我们在制作Framework的时候暴露的头文件，所有被暴露的.h都放在这里。
binary文件
整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。
.bundle
资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。
注意：图片放进bundle之后不可以用[UIImage ImageWithName:]读取图片。要先找到bundle包再拿图片。

3. .dylib/.tbd 动态库
这类动态库我们也经常用，基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。



iOS中动态库的使用
iOS8 之前，苹果不允许第三方框架使用动态方式加载。
iOS8 开始，允许开发者有条件地创建和使用动态框，但和系统的framework不同，其被放到 app  main bundle 的根目录 中，运行在沙盒里，而不是系统中。
a:使用自定义的动态库的方式来动态更新只能用在 in house(企业发布) 和develop 模式中
b:不能在使用到 AppStore，




4.被运行 运用的条件








framwork/library被运用
1.同一个项目中
a:系统的
1.在PBXFileReference中 增加 系统库文件夹:path = System/Library/Frameworks/AVFoundation.framework;
2.在PBXBuildFile 中  增加 对 引用文件的引用，作为编译文件
3.在PBXFrameworksBuildPhase中 增加 对 编译文件的 引用，作为链接文件

b:三方的
2.同一个xcworkspace，不同项目中
*/
