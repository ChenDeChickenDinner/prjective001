/*
库：
1.是什么：是程序代码的集合
2.分类：
开源库：源代码是公开的，可以看到每个实现文件（.m文件）的实现 ===》(被别人使用)
闭源库：不公开源代码，是经过编译后的二进制文件，看不到具体的实现 ===》(被别人使用，但隐藏其实现部分)


闭源库：
1.从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。


2.库分静态库和动态库两种，是相对编译期和运行期的的角度来说的
    静态库：在链接阶段，会将目标文件与静态库，一起链接打包到可执行文件中，如果多个程序用到，都会将其打包进自己的可执行文件中。程序运行阶段就不需要它了；
        1.一起与目标文件打包==》造成可执行文件 偏大
        2.谁用到谁就要将其 拷贝打包一份==>造成多次拷贝
        3.被打进可执行文件中，运行则不需要它==》好处：不需要外部依赖，若库发生变化 则需要重新 编译


    动态库：动态库把对一些库函数的链接载入推迟到程序运行的时期（公用一份，不用拷贝，节省空间，增量更新），但一旦链接期间找不到就会崩溃，没静态库安全
          1 .framework可以选择公开头文件



iOS中二进制文件形式
    .a 是一个纯二进制文件，要有 .h 文件以及资源文件配合。
    .framework 本身已经包含了.h和其它文件，可以直接使用
    .dylib/.tbd 动态库基本上都是系统提供的，一般不能自己制作，就算你通过其他方式制作使用，也肯定不能上架的，这里没什么好讲的。


iOS中静态库和动态库的存在的形式
    静态库：以.a  + 个人打的framework
    动态库：以.tbd/.dylib +  系统的framework

 iOS中静态库和动态库的存在的形式特点
     A: .a形式静态库
          1.（.a 中 只能 包含实现文件，不能包含 头文件 跟资源文件）=====（.h + .a + bunld 合成一个文件夹）
          2. 所有的头文件都会被公开
     B: .framework形式静态库
         1.Framework本质上并不是一个库，它是苹果为了方便开发者提供了一种库的打包方式
         2.主要由Headers、binary文件、.bundle这三部分构成，除此之外还有Info.plist和Modules，后两者主要记录Framework的版本之类的信息，一般都会删掉
             Headers:包含我们在制作Framework的时候暴露的头文件,可以选择性暴露
             binary文件:整个Framework的核心，所有代码都被编译成了这样一坨二进制文件，这里要注意的是添加的依赖库不会被编译进来，用的时候还需要重新link其他依赖库。
             bundle:资源文件都打包放在这里。在制作Framework的时候不可以把图片直接放在项目中，否则制作好之后图片是一张一张的出现在项目中非常乱，需要新建一个bundle将图片放进去，这里的bundle提供整个SDK的图片资源。注意：图片放进bundle之后不可以用[UIImage ImageWithName:]读取图片。要先找到bundle包再拿图片。


制作静态库
1 打.a 静态库

2 打.a多种依赖形式的处理
 b:源码 + 对系统动态库的依赖 === 》包中 只会包含系统库的头文件，并不会将系统打进包中，动态库 只在运行时 用到。并在文档中注明 依赖的系统库
 c:源码 + 自身私有库/三方私有库 ===》包中 只包含 私有库头文件，最后的文件中，将三方库 与自身库 放在一起。不要讲库打进自己的包中
 e:源码 + 三方开源库 === 》包中 只会包含系统库的头文件，并在文档中注明 依赖的系统库以及版本信息


2.打.Framework静态库


3.打.Framework动态库
此时这个动态库会跟静态库一样被拷贝到目标程序中进行编译，苹果又把这种Framework叫做Embedded Framework




 1.制作 静态库 Build Setting 设置 通用步骤

 1.Build Setting 设置（有哪些 对 其的运用有影响）
     1.支持的硬件平台:支持的机型

     Deployment阶段
     1.Deployment Target:最低支持系统的版本（重要）

     linking阶段
     1.Dead code stripping:编译选项优化,包瘦身
     2.Mach-O Type:最后生成二进制文件的格式（重要，当打静态库时候要选择StaticLibrary，打动态库时候选择默认的）
     3.Other Linker Flags

 2.BuildPhases 设置，添加需要暴露的头文件
     1.对于.a ,在copy files phase 中添加
     2.对于.frameark 在   headers phase 中添加 设置，暴露的 ，受保护的 头文件

 3.选择 运行环境 debug/release 在 run 构建中设置（重要，根据 需要 选择  debug/release ）
 4.选择 运行平台（模拟 /真机、模拟+真机）（重要，选择其实在 模拟器上运行 还是在真机上 还是二者都可以）
 4.编译  出包===》合并 静态库






 被使用本质===》不看外部原因（不论在哪） 被使用步骤
1.添加进项目，让Xcode 生成 正确的 搜索路径，让项目在链接阶段能找到对应的库
2.在 Link Binary with Libraries 添加 引用的 库 跟 依赖的库，若是动态库 还需要在Embedded Binaries中导入


 iOS中动态库的使用
 iOS8 之前，苹果不允许第三方框架使用动态方式加载。
 iOS8 开始，允许开发者有条件地创建和使用动态框，但和系统的framework不同，其被放到 app  main bundle 的根目录 中，运行在沙盒里，而不是系统中。
 a:使用自定义的动态库的方式来动态更新只能用在 in house(企业发布) 和develop 模式中
 b:不能在使用到 AppStore，
*/
