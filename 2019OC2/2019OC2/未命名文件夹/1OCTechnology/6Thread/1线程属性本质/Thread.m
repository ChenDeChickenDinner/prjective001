//
//  Thread.m
//  2019OC2
//
//  Created by xs on 2019/3/1.
//  Copyright © 2019 Touker. All rights reserved.
//

#import "Thread.h"

@implementation Thread

@end
/*
 1 进程
 1）进程是指在系统中正在运行的一个应用程序。
 2）每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。

 2 线程
 2.1）基本概念
 a.1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）；
 b.线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。

 2.2）线程的串行
 a.1个线程中任务的执行是串行的;
 b.如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务;
 c.也就是说，在同一时间内，1个线程只能执行1个任务。

 2.3)主线程
 ① 显示|刷新UI界面
 ② 处理UI事件
 ① 耗时操作不能放在主线程,否则卡住UI
 ② 所有UI操作必须在主线程中执行

 2.4)线程的生命周期 以及状态
 1.新建:new
 2.就绪:start,进入可调度线程池
 3.运行中:running,
 4.阻塞中:调用了sleep方法\等待同步锁,退出可调度线程池
 5.死亡:线程任务执行完毕，异常\强制退出

 线程内存管理 ，比如 当一个线程 属于一个对象，当对象提前释放掉了
 子线程里开子线程，第一个挂了





 3 多线程
 1）基本概念
 即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。
 2）线程的并行
 并行即同时执行。比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C。
 3）多线程并发执行的原理
 a.在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）;
 b.多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象;

 4）多线程优缺点
 优点
 1）能适当提高程序的执行效率。
 2）能适当提高资源利用率（CPU、内存利用率）
 -----------
 缺点
 1）开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。
 2）线程越多，CPU在调度线程上的开销就越大。
 3）程序设计更加复杂：比如线程之间的通信、多线程的数据共享

 多线程的安全隐患
 安全隐患
 1.1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源
 2.比如多个线程访问同一个对象、同一个变量、同一个文件

 线程异步
 a.当多个线程试图在几乎同一时间对同一变量做增量操作而不进行同步的话，结果就可能出现不一致

 线程同步
 b.即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态
 c.同字从字面上容易理解为一起动作,其实不是，“同”字应是指协同、协助、互相配合
 d.所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回，同时其它线程也不能调用这个方法


 实现线程同步依据
 @synchronized(self){

 }

 线程间通信

 */

/* GCD和NSOperation的对比：
 1）GCD是纯C语言的API,而操作队列则是Object-C的对象。
 2）在GCD中，任务用块（block）来表示，而块是个轻量级的数据结构；
 相反操作队列中的『操作』NSOperation则是个更加重量级的Object-C对象。
 3）具体该使用GCD还是使用NSOperation需要看具体的情况


 NSOperation和NSOperationQueue的好处有：
 1）NSOperationQueue可以方便的调用cancel方法来取消某个操作，而GCD中的任务是无法被取消的（安排好任务之后就不管了）。
 2）NSOperation可以方便的指定操作间的依赖关系。
 3）NSOperation可以通过KVO提供对NSOperation对象的精细控制（如监听当前操作是否被取消或是否已经完成等）
 4）NSOperation可以方便的指定操作优先级。操作优先级表示此操作与队列中其它操作之间的优先关系，优先级高的操作先执行，优先级低的后执行。
 5）通过自定义NSOperation的子类可以实现操作重用.
 */
