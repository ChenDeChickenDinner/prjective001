//
//  main.m
//  review
//
//  Created by xs on 2018/11/7.
//  Copyright © 2018 Touker. All rights reserved.
//

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // insert code here...
        NSLog(@"Hello, World!");
    }
    return 0;
}
void test1(){


}
void test1(){
     /*
      数的各种进制 以及表示方法
      二进制:组成(由 0 ~ 1 组成),写法(由0b/0B 开头表示二进制数)
      八进制:组成(由 0 ~ 7 组成),写法(由0开头表示)
      十进制:组成(由 0 ~ 9 组成),写法(默认就是十进制数)
      十六进制组成(由 0 ~ 9/a/A~f/F 组成),写法(0X/0x开头)
      在计算机中10进制数有正负之分,其它没有

      二进制转十进制
      a:次方
      当n≠0的时候，n的0次方=1，而n的1次方=n
      当n=0的时候，0的0次方无意义，而0的1次方有意义，就等于0

      b:转十进制
      1100 = 0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 = 0 + 0 + 4 + 8 = 12
      N         4        3         2        1        0
      Xn        X4       X3        X2       X1       X0
      Xn*2^n  + X4*2^4 + X3*2^3  + X2*2^2 + X1*2^1 + X0*2^0

      c: n位2进制数的取值范围
      1位: 0 ~ 1*2^0(1) = 1
      2位: 0 ~ 1*2^0(1) + 1*2^1(2) = 3
      3位: 0 ~ 1*2^0(1) + 1*2^1(2) + 1*2^2(4) = 7
      4位: 0 ~ 1*2^0(1) + 1*2^1(2) + 1*2^2(4) + 1*2^3(8) = 15
      5位: 0 ~ 1*2^0(1) + 1*2^1(2) + 1*2^2(4) + 1*2^3(8) + 1*2^4(16) = 31
      6位: 0 ~ 1*2^0(1) + 1*2^1(2) + 1*2^2(4) + 1*2^3(8) + 1*2^4(16) + 1*2^5(32) = 63
      7位: 0 ~ 1*2^0(1) + 1*2^1(2) + 1*2^2(4) + 1*2^3(8) + 1*2^4(16) + 1*2^5(32) + 1*2^6(64) = 127
      8位: 0 ~ 1*2^0(1) + 1*2^1(2) + 1*2^2(4) + 1*2^3(8) + 1*2^4(16) + 1*2^5(32) + 1*2^6(64) + 1*2^7(128) = 256
      N位:0  ~  2^N - 1


      十进制转二进制
      a)整数部分:67
      1.67/2 = 33 余 1 最低位
      2.33/2 = 16 余 1
      3.16/2  = 8 余 0
      4.8/2  = 4 余 0
      5.4/2  = 2 余 0
      6.2/2  = 1 余 0
      7.1/2  = 0 余 1  最高位 （最后的商必须<1）
      =1000011

      b)小数部分:0.625
      1.0.625 * 2 = 1.25【小数部分*2得到的积】==>取出整数部分 1 为最高位
      2.上积的小数部分0.25 * 2 = 0.5【得到的积】==>取出整数部分 0 第二高位
      3.上积的小数部分 0.5 * 2 = 1   【得到的积】==>取出整数部分 1 第三高位
      4.到积中的小数部分为零
      =101

      c)合并实数   67.625 = 1000011.101
      c)合并实数   -67.625 = -1000011.101
      2.二进制实数的科学计数法
      a:有效数字
      1.有效数字:是指从该数字左边第一个非0的数字到该数字末尾的数字个数（）
      2.3一共有1个有效数字，0.0003有一个有效数字，0.1500有4个有效数字，1.9×103有两个有效数字

      十进制科学技术法
      1.把一个数表示成a与10的n次幂相乘的形式（1≤a<10，n为整数）
      2.若|x|>1，则记为ax10^n的形式，n的值由 x的位数决定，若m为x的位数，则 n = m-1;
      138000 = 1.38x10^5
      - 138000 = -1.38x10^5
      3.若|x|<1，则记为ax10^-n的形式，
      0.025 = 2.5x10^-2
      -0.025 = -2.5x10^-2

      二进制学技术法
      67.625 = 1000011.101 = 1.000011101x2^6
      -67.625 = -1000011.101 = -1.000011101x2^6

      0.625 = 0.101 = 1.01x2^-1;
      -0.625 = 0.101 = -1.01x2^-1;

      */
}
void test11(){
    /*


     */

    /*数的存储
     机器数
     1.机器数:是将符号"数字化"的数，是数字在计算机中的二进制表示形式
     特点a:一是符号数字化，用一个数的最高位存放符号, 正数为0、负数为1。
     特点b:二是其数的大小受机器字长的限制

     2.机器数的表示格式:(根据小数点位置固定与否，机器数又可以分为定点数和浮点数。)
     a:定点格式，即约定机器中所有数据的小数点位置是固定不变的【使用定点数表示整数】
     b:浮点格式，【而用浮点数表示实数】

     3.机器数3种形式：原码、反码和补码
     真值:+8 与 -8
     1.因为第一位是符号位，所以机器数的形式值就不等于真正的数值
     2.将带符号位的机器数对应的真正数值称为机器数的真值

     原码:符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值。（其实就是机器数）
     +8的原码:0000 0100
     -8的原码:1000 0100
     +0的原码:0000 0000
     -0的原码:1000 0000  (0的原码 有二个)

     反码:
     正数:正数的反码 = 原码 【+8的反码:0000 0100】
     负数:在原码的基础上，符号位不变其他位按位取反(就是0变1，1变0)【-8的反码:1111 1011】
     +0的反码:0000 0000
     -0的反码:1111 1111


     补码:
     正数:正数的补码 = 原码 【+8的补码:0000 0100】
     负数:在反码的基础上按照正常的加法运算加1【-8的反码:1111 1011 + 1 = 1111 1100】
     +0反码:0000 0000
     -0反码:1111 1111 + 1 =  10000 0000 ===> 1进位被丢弃 ===> 0000 0000


     原码反码 补码 总结
     1.计算机可以有三种编码方式表示一个数，对于正数因为三种编码方式的结果都相同
     2.原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢?
     3.因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位选择对真值区域的加减
     4.计算机辨别"符号位"会让计算机的基础电路设计变得复杂，于是，人们想出了将符号位也参与运算的方法
     5.根据运算法则，减去一个正数等于加上一个负数，即：1-1 = 1 + (-1)，所以机器可以只有加法而没有减法，
     6.于是人们就开始探索将符号位参与运算并且只保留加法的方法
     7.为了解决原码做减法的问题，出现了反码
     8.于是补码出现了，它解决了0的符号以及两个编码的问题：

     整数的存储:
     1.1 正整数  在计算机中 是以原码的形式 存储的。
     1.2 负整数 在计算机中 是以 补码的形式 存储的。
     一个字节的表示范围
     a.无符号
     b.有符号
     */
}
void test12(){
/*IEEE-754(二进制浮点科学计数法)
 1.将一个二进制科学计数 利用 IEEE 存起来【把小数点移动到整数位只有1】
 例如1：1.000011101x2^6; |-1.000011101x2^6;
 例如2：1.01x2^-1; | -1.01x2^-1;

 a)规则:在IEEE标准中，浮点数是将特定长度的连续字节的所有二进制位分割为特定宽度的符号域、指数域和尾数域这三个域
 b)二种浮点格式:

 占位    符号位    阶码    尾数    长度
 float      1      8      23    32
 double     1     11      52    64
 符号位：0正 1负
 阶码：指数部分 【阶码的值(十进制) = 阶码基数(十进制)  + 指数(十进制)】===》再转换成二进制
 尾数：有效数部分【将小数后面的二进制位依次从高到底排列后面补0】
 阶码基数:
 a.因为指数部分会有正有负，而IEEE标准中 不想指数部分出现负数,想办法让指数都是正数，以此还省略了符号位来表示负数 提高了精度
 b:单精度为127(01111111)，双精度为1023(01111111111)

 例1:将67.625 计算出。。
 1.转换成二进制数
 a:整数部分 =1000011
 b:小数部分 =101
 c:合并 = 1000011.101
 2.将二进制数转换成 科学计数法
 1000011.101 = 1.00011101 x2^6
 符号位:0
 阶码: 127 + 6 = 133 = 10000101
 尾数: 出掉整数部分的1，小数点后面的数 = 00011101
 合并: 0 10000101 00011101+ 后面的零

 4.IEEE-754所带来的问题

 a.阶码，float的 阶码 占用 8位二进制位【有限的位数 --->决定数的数量级】
 1.(本可以表示的最大指数)8 位的指数为可以表达 0 ~ 255 之间的 256 个指数值
 2.(负指数)为了处理负指数的情况，实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值，单精度数的偏差值为 127；
 3.(偏差值的用法)
 */
}
void test33(){
    /* 字符的表达_编码
     ASCII码字符集（使用指定的7 位来表示128个字符）
     a:非显示字符【 0~31 以及 127(共33个) 表示控制字符或通信专用字符 其中特殊的为(0:空字符 )】
     b:显示字符【32～126(共95个) 表示 所以的 数组 字符 以及 符号其中特殊的为(32:空格 )】
     c:在内存中占用一个字节 最高位为 0
     拓展EASCII
     a:将ASCII码由7位扩充为8位（增加了128个）而成。 EASCII 的内码是由0到255共有256个字符组成
     */
}
void test32(){
    /* 数的运算

     */
}

void con_float(float n){
    for(unsigned int i=0,j=0x80000000;i<32;i++)
    {
        printf("%d",(*(unsigned int*)&n)&j>>i?1:0);
        if((i+1)%4==0&&i<31)
            printf(".");
        if(i==31)
            printf("\n");
    }
}
