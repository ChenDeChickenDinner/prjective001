//
//  main.m
//  NO5
//
//  Created by xs on 2018/10/12.
//  Copyright © 2018年 Touker. All rights reserved.
//

#import <Foundation/Foundation.h>
#include "struct.h"


void test5();
int main(int argc, const char * argv[]) {
    @autoreleasepool {
//        test5();
        struct person my = {15};
        printf("my.age = %d\n",my.age);
    }
    return 0;
}
/**
 内存
 */
void test1(){
/*
位(bit):
 1.为信息量的最小单位，二进制数的一位所包含的信息就是一比特
*/


/*
字节(byte)
【b7、b6、b5、b4、b3、b2、b1、b0】
1.一个字节由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）
2.是计算机中数据处理的基本单位
 */

/*
内存地址
1.是内存当中存储数据的一个标识，并不是数据本身，通过内存地址可以找到内存当中存储的数据
2.内存地址以十六进制表示【0x7ffeefbff5df】
3.一个字节（8bit）拥有一个内存地址
 */

/*
排列
 0x7ffeefbff5df
 0x7ffeefbff5de
 0x7ffeefbff5dd
 0x7ffeefbff5dc
 0x7ffeefbff5db
 */
/*

内存分配方式
 静态存储分配
 1.发生在程序编译和连接的时候，需要预先分配固定的存储空间
 动态存储分配
 1.在程序执行的过程中动态地分配或者回收，且分配的大小就是程序要求的大小


内存分区
 代码区:
 1.程序被操作系统加载到内存的时候，所有的可执行代码都加载到代码区，这块内存在程序运行期间是不变的。
 2.代码区是平行的，里面装的就是一堆指令，在程序运行期间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。
 3.注意："int a = 0;"语句可拆分成"int a;"和"a = 0"，定义变量a的"int a;"语句并不是代码，它在程序编译时就执行了，并没有放到代码区，放到代码区的只有"a = 0"这句。

 静态数据区:
 1.主要存放静态变量、全局变量和常量
 2.静态存储区内的常量分为常变量和字符串常量，在程序编译阶段已经分配好内存空间并初始化,一经初始化，不可修改,
 3.这块内存在程序的整个运行期间都存在


 动态数据区(堆栈):
 栈区:
1.静态分配，动态分配
2.内存分配由大--->小
3.编译器自动管理，无需程序员手工控制，存放函数的参数值，局部变量值等
 堆区:
1.动态分配
2.内存分配由小--->大
3.申请释放工作由程序员控制，容易产生内存泄漏

 */
}



/**
 变量与内存
 1.
 例如: int a = 1;
0x7ff5(一字节) 0000 0000
0x7ff4(一字节) 0000 0000
0x7ff3(一字节) 0000 0000
0x7ff2(一字节) 0000 0001
0x7ff1(一字节)
0x7ff0(一字节)

1.从[0x7ff5-->0x7ff2]分配给 变量 a【内存寻址从大到小】
2.0x7ff2 为变量 a 的地址【最低地址为变量的地址， & 操作符 可以取变量的地址】
3.从地址最大的位置开始存储数据
 */
void test11(){

    /*
     0.
     1.局部变量 存放与栈中，由大到小寻址分配
     2.int 占 4个字节 a 与 b 的地址相差 4;
     3.
         a = 0x7ffeefbff5bc
         b = 0x7ffeefbff5b8
     */
    int a = 1;
    int b = 1;
    printf("a = %p\nb = %p\n",&a,&b);
}
/**
 构造数据类型-数组【一组相同数据类型数据的有序的集合 ====>数组类型 + 数组名[元素个数]】
 数组类型:数组的类型由元素类型和数组大小共同决定
 数组名:标识符
 元素个数:为整形常量表达式 ，不能为变量，当未指定元素的时候 元素个数是必须的
 */
void test2(){
    // 1.初始化
    int array1[6]; // 未初始化的元素的值是不确定的

    // 2.初始化的元素 必须是常量 或者 常量表达式
    int array2[3] = {1,2,3};//整体全初始化
    int array3[3] = {1,2}; // //前面部分初始化
    int array4[3] ={[0]=1,[1]=2};//指定位置初始化
    int array5[] = {1,2,3,4};//元素个数由初始化的元素确定

    // 2.数组长度
    int length = sizeof(array2)/sizeof(int);

    // 2.元素赋值取值
    int a = array2[0]; // 第一个元素 从 0 开始

    int b = array2[length-1];// 最后一个元素 为  length-1 开始


     /*在内存中的表现
      1.从地址小的位置开始给每个元素分配空间 地址低[0]------->地址高[length-1]
      array = 0x7ffeefbff551
      array[0] = 0x7ffeefbff551
      array[1] = 0x7ffeefbff552
      array[2] = 0x7ffeefbff553
      */
    char array[] = {'1','2','3'};
    int length2 = sizeof(array)/sizeof(char);
    printf("array = %p\n",array);
    for (int i = 0; i<length2; i++) {
        printf("array[%d] = %p\n",i,&array[i]);
    }

//  在数组中，数组变量是不能彼此赋值的
//   array1 = array2;


}

/**
 二维数组
 */
void test4(){
    /*
    1.所谓二维数组就是一个一维数组的每个元素又被声明为一 维数组,从而构成二维数组. 可以说二维数组是特殊的一维数组。
    2.格式 数据类型 数组名[一维数组的个数][一维数组的元素个数]
    3.其中"一维数组的个数"表示当前二维数组中包含多少个一维数组
    4.其中"一维数组的元素个数"表示当前前二维数组中每个一维数组元素的个数
     */
    char number[2][5] = {"it","chen"};

    /*二维数组的初始化(分为两种)
     */
    int a1[2][3]={ {80,75,92}, {61,65,71}}; //1.定义的同时初始化

    int a[2][3]; // 先定义后初始化
    /*二维数组的 取值 赋值
     1.必须 以 数组名加二个连续的下标 才能访问元素 number[2][5]
     */
    a[0][0] = 80;
    a[0][1] = 75;
    a[0][2] = 92;
    a[1][0] = 61;
    a[1][1] = 65;
    a[1][2] = 71;

    // 初始化赋值多种方式
    int a[2][3]={ {80,75,92}, {61,65,71}}; // 按行分段赋值
    int a[2][3]={ 80,75,92,61,65,71}; // 按行连续赋值

    // 完全初始化,可以省略第一维的长度
    int a[][3]={{1,2,3},{4,5,6}};
    int a[][3]={1,2,3,4,5,6};

    // 部分初始化,可以省略第一维的长度
    int a[][3]={{1},{4,5}};
    int a[][3]={1,2,3,4};


}
/**
 字符串数组
 */
void test41(){
    char number[2][5] = {"it","chen"};
}
/**
 结构体
 1.是用于保存一组不同类型数组的
 2.在使用结构体之前必须先定义结构体类型
 3.格式
     struct　结构体名{
         类型名1　成员名1;
         类型名2　成员名2;
         ……
         类型名n　成员名n;
     };
 */
void test5(){
    // 定义类型此时并未 分配存储空间
    struct person{
        int age; //年龄 4
        char *name;//姓名 8
        double height;//身高 8
    };

    //    初始化，将各成员的初值，按顺序地放在一对大括号{}中，并用逗号分隔，一一对应赋值；此时已经分配存储空间
    struct person my = {18,"xiao",1.80};
    struct person you  = {.age = 20,.height = 1.55};
    // my = {11,"xiao",1.10}; 只要在初始化的时候可以这种赋值方式

   //    "."称为成员运算符，它在所有运算符中优先级最高
    my.age = 19;
    my.name = "okok";
    printf("my.age = %d,my.name = %s\n",my.age,my.name);

    int age = my.age;
    char *name = my.name;
    double height = my.height;

     //相同类型的结构体变量之间可以进行整体赋值
    my = you;
    printf("my.age = %d,my.name = %s\n",my.age,my.name);


    /* 成员变量的类型要求
     1.可以包含任何数据类型 基本数据类型 字符 数据 指针 其它结构体 枚举
     2.不能嵌套包含自己
     */

    /* 内存存储
     1.给结构体变量开辟存储空间和给普通开辟存储空间一样, 会从内存地址大的位置开始开辟
     2.给结构体成员开辟存储空间和给数组元素开辟存储空间一样, 会从所占用内存地址小的位置开始开辟
     3.结构体变量占用的内存空间永远是所有成员中占用内存最大成员的倍数(对齐问题)
     */
    printf("my.sizeof = %lu\n",sizeof(my));//    my.sizeof = 24


    /* 类型作用域
     1.结构类型定义在函数内部的作用域与局部变量的作用域是相同的[ 从定义的那一行开始, 直到遇到return或者大括号结束为止]
     2.结构类型定义在函数外部的作用域与全局变量的作用域是相同的[从定义的那一行开始,直到本文件结束为止]
     3.定义在函数外的 类型 只要文件被其它地方所引用，别的地方也可以运用此类型，枚举同此
     */

    //结构体数组
    struct person array[2] = {{18,"xiao",1.80},{19,"xiao",1.90}};
    struct person who = array[1];
    printf("who.age = %d\n",who.age);
    int age2 = array[0].age;
}
