//
//  Interface2.h
//  1111
//
//  Created by xs on 2020/11/13.
//

#import "@property.h"

#pragma warning-继承
/*
 1.子类拥有父类的全部属性、方法
 2.子类可以重写父类的方法实现
 3.父类指针可以指向子类对象 多态
 */
@interface Interface2 : Interface1

@end
#pragma warning-扩展
/*
 1.可以为元类添加新的属性跟方法，在编译阶段就整合到类的数据结构中去的，就是类的一部分
 2.类扩展无单独的@implementation 部分，必须依托对应类的实现部分来实现，所以你无法为系统的类添加extension
 3.定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的
 */
@interface Interface2()

@end
#pragma warning-分类
/*
  typedef struct category_t *Category;
  //category加载
  1.编译阶段:一个分类就是一个 category_t 类型的变量
  2.运行时:利用运行时机制把分类中的方法都添加到类跟元类中去
  3.结果:
  1.category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，
  那么category附加完成之后，类的方法列表里会有两个methodA
  
  2.category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，
  这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，
  这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的
  
  3.类对象:[分类方法列表(最后编译的分类在最前面)][分类方法列表][分类方法列表]
  
 // 分类对方法调用的影响-方法覆盖
  1.通过方法地址调用的方法 是不受分类影响的，比如分类中的load
  2.通过runtime消息机制调用的方法，分类会对其有影响，造成覆盖的假象
  
  //分类中使用@property
  1.仅仅作为方法的声明使用，一般配合readonly  readwrite,只实现一个
  2.利用关联对象达到添加属性的效果
  
  //分类的方法会被子类继承吗

 1.如果分类中有和原有类同名的方法, 会优先调用分类中的方法, 就是说会忽略原有类的方法，同名方法调用的优先级为 分类 > 本类 > 父类；
 2.如果多个分类中都有和原有类中同名的方法, 那么调用该方法的时候执行谁由编译器决定；编译器会执行最后一个参与编译的分类中的方法
 */
@interface Interface2(Category)

@end
