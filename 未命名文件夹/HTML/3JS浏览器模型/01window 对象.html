<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
/*
    浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎

1.渲染引擎
1.渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档
2.不同的浏览器有不同的渲染引擎
3.渲染引擎处理网页，通常分成四个阶段。以下四步并非严格按顺序执行
    a.解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
    b.对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
    c.布局：计算出渲染树的布局（layout）。
    d.绘制：将渲染树绘制到屏幕
4.重流和重绘
1.渲染树转换为网页布局，称为“布局流”（flow）；
2.布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源
3.页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。

2.JavaScript 引擎

1.JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行
2.早期，浏览器内部对 JavaScript 的处理过程如下：
a.读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。
b.对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。
c.使用“翻译器”（translator），将代码转为字节码（bytecode）。
d.使用“字节码解释器”（bytecode interpreter），将字节码转为机器码

3.网页中嵌入 JavaScript 代码，主要有三种方法。
1.元素事件属性
<div onclick="console.log('123')"></div>
2.script元素直接嵌入代码。
<!-- <script>console.log('123')</script> -->
3.script标签加载外部脚本
<!-- <script src="https://www.example.com/script.js"></script> -->


2.JavaScript 执行
浏览器加载 JavaScript 脚本，主要通过script元素完成。正常的网页加载流程是这样的。
1.浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。
2.解析过程中，浏览器发现script元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。
3.如果script元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。
4.JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。

defer 属性
1.发现带有defer属性的script>元素,浏览器继续往下解析 HTML 网页，同时并行下载script元素加载的外部脚本
2.浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本

async 属性
1.发现带有async属性的script标签,浏览器继续往下解析 HTML 网页，同时并行下载script标签中的外部脚本
2.脚本下载完成，浏览器暂停解析 HTML 网页，开始执行脚本
3.脚本执行完毕，浏览器恢复解析 HTML 网页

*/
<script>
    // window.self和window.window属性都指向窗口本身。这两个属性只读。
    window.self;
    window.window;


    window.name;//属性是一个字符串，表示当前浏览器窗口的名字
    window.closed;//返回一个布尔值，表示窗口是否关闭。
    // 表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回null
    window.opener();

    window.frames;//返回一个类似数组的对象，成员为页面内所有框架窗口
    window.length;//属性返回当前网页包含的框架总数
    window.frameElement;//属性主要用于当前窗口嵌在另一个网页的情况
    window.top;//属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。

    window.parent;//属性指向父窗口。如果当前窗口没有父窗口，window.parent指向自身

    // 组件属性：组件属性返回浏览器的组件对象。这样的属性有下面几个。

    window.locationbar;//地址栏对象
    window.menubar;//菜单栏对象
    window.scrollbars;//窗口的滚动条对象
    window.toolbar;//工具栏对象
    window.statusbar;//状态栏对象
    window.personalbar;//用户安装的个人工具栏对象

        // 全局对象属性指向一些浏览器原生的全局对象
    window.document;//指向document对象，注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。
    window.location;//指向Location对象，用于获取当前窗口的 URL 信息。它等同于document.location属性
    window.navigator;//指向Navigator对象，用于获取环境信息
    window.history;//指向History对象，表示浏览器的浏览历史
    window.localStorage;//指向本地储存的 localStorage 数据
    window.sessionStorage;//指向本地储存的 sessionStorage 数据
    window.console;//指向console对象，用于操作控制台
    window.screen;//指向Screen对象，表示屏幕信息

    // 属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是true，否则就是false
    window.isSecureContext;

    // 都是浏览器与用户互动的全局方法。
    // 它们会弹出不同的对话框，要求用户做出回应。
    // 注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。
    window.alert();
    window.prompt();
    window.confirm();


    // window.open方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回null。
    window.open('目标html地址');

    // window.close方法用于关闭当前窗口，一般只用来关闭window.open方法新建的窗口
    window.closed();
    // window.stop()方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象
    window.stop();

    // 激活窗口，使其获得焦点，出现在其他窗口的前面
    window.focus();
    // 将焦点从窗口移除。
    window.blur();

    // load事件发生在文档在浏览器窗口加载完毕时。window.onload属性可以指定这个事件的回调函数
    window.onload = function(){

    };
    // 浏览器脚本发生错误时，会触发window对象的error事件
    // 出错信息,出错脚本的网址,行号,列号,错误对象
    window.onerror = function(message, filename, lineno, colno, error){
        console.log("出错了！--> %s", error.stack);

    };

    // 用户变成在线会触发online事件，变成离线会触发offline事件，可以通过window.ononline和window.onoffline指定这两个事件的回调函数
    function online(){
    };
    function offline(){

    };
    window.addEventListener('offline', function(offline) { console.log('offline'); });
    window.addEventListener('online', function(online) { console.log('online'); });
  
    // 多窗口操作
    // 1.由于网页可以使用iframe元素，嵌入其他网页，因此一个网页之中会形成多个窗口。
    // 2.如果子窗口之中又嵌入别的网页，就会形成多级窗口。
    // 3.各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口
</script>
</body>
</html>