<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    window.alert
    /*函数的定义
    1.function指出这是一个函数定义；
    2.abs是函数的名称；
    3.(x)括号内列出函数的参数，多个参数以,分隔；不用写var 直接写变量名
    4.{ ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。
    5.如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined
    */
    function abs(){

    }
    /* 匿名函数
    1.由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量
    2.在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。
    */
    var funValue =  function(){

    };
    /*函数的参数 
参数规则
 JavaScript 函数定义显式参数时没有指定数据类型。
JavaScript 函数对隐式参数没有进行类型检测。
JavaScript 函数对隐式参数的个数没有进行检测。

默认参数
ES5 中如果函数在调用时未提供隐式参数，参数会默认设置为： undefined
有时这是可以接受的，但是建议最好为参数设置一个默认值：
function myFunction(x, y) {
    if (y === undefined) {
          y = 0;
    } 
}

Arguments 对象
JavaScript 函数有个内置的对象 arguments 对象。
argument 对象包含了函数调用的参数数组。

参数传递:值传递
在函数中调用的参数是函数的隐式参数。
JavaScript 隐式参数通过值来传递：函数仅仅只是获取值。
如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）。
隐式参数的改变在函数外是不可见的。
参数传递:对象传递
在JavaScript中，可以引用对象的值。
因此我们在函数内部修改对象的属性就会修改其初始的值。
修改对象属性可作用于函数外部（全局变量）。
修改对象属性在函数外是可见的

参数类型判断
1.原生不检查参数类型，这是由于js是弱数据类型的语言
2.一般情况下输入参数类型是写代码的人预先就想好的了，所以一般不会出现这种问题
3.如果涉及用户输入或者交互产生数据的时候，就有可能会出现题主的情况。
做法就是通过自定义方法判断数据类型之后在进行处理
    */
/**
* 判断传入参数类型
*/
function isArray(obj){    //数组类型
  return (typeof obj=='object')&&obj.constructor==Array; 
};
function isString(obj){    //字符串类型
  return (typeof obj=='string')&&obj.constructor==String; 
};
function isNumber(obj){    //数值类型
  return (typeof obj=='number')&&obj.constructor==Number; 
};
function isDate(obj){    //日期类型
  return (typeof obj=='object')&&obj.constructor==Date; 
};
   /*函数的调用
    1.通过函数名直接调用
    2.通过匿名函数对象调用
    */
    abs();
    funValue();

/*函数的嵌套
1.所有函数都能访问全局变量。  
2.实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。
3.JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。
*/

 
/* 函数的作用域
1.JavaScript不支持函数的重载
　　JavaScript没有方法重载的说法，如果两个方法名字一样，即使参数个数不一样，那么后面定义的就会覆盖前面定义，调用方法时永远是调用后定义的那个


*/
    </script>
</body>
</html>