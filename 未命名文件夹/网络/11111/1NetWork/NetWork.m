//
//  NetWork.m
//  11111
//
//  Created by xs on 2019/3/6.
//  Copyright © 2019 Touker. All rights reserved.
//

#import "NetWork.h"

@implementation NetWork

@end
//TCP/IP
/*
链路层:
 1.链路层定义了主机的身份即MAC地址;
 2.主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。
 3.太网协议:以太网协议通过对电信号进行分组并形成数据帧，然后通过物理介质把数据帧发送给接收方

数据单位:数据帧
1.以字节为单位对 0 和 1 进行分组
2.一组电信号就是一个数据包
3.一个数据包被称为一帧


数据帧组成:由首部、数据和尾部三部分组成
1.首部固定为14个字节，包含了目标MAC地址、源MAC地址和类型
2.数据最短为46个字节，最长为1500个字节，超过则分割成多个帧进行发送
3.尾部固定为4个字节，表示数据帧校验序列，用于确定数据包在传输过程中是否损坏

身份验证:以太网如何来识接收方的身份呢？
1、即网卡,数据包必须是从一块网卡传送到另一块网卡。而网卡地址就是数据包的发送地址和接收地址，也就是帧首部所包含的MAC地址

数据传递:
1.有了MAC地址以后，以太网采用广播形式，把数据包发给该子网内所有主机，
2.子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，
3.然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包


 链路层 问题
 发送者如何知道接收者的MAC地址？
 发送者如何知道接收者和自己同属一个子网？
 如果接收者和自己不在同一个子网，数据包如何发给对方？

 */
/*


 网络层:
1.而网络层定义了IP地址，明确了主机所在的网段
2.网络层的主要工作是定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由


 IP协议:
 1.问题:是否同属一个网络
 2.解决:网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址
 a.IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址
 b.如果两个IP地址在同一个子网内，则网络地址一定相同
 c.因此我们只要通过子网掩码对两个IP地址进行AND运算后就能够判断双方是否在同一个子网了。

 ARP协议:
 1.问题:根据IP 取MAC
 2.解决:
 a.ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机
 b.每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据
 c.ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间

 路由协议
 1.问题:
 2.解决:



IP协议+ARP协议+ 路由协议
1.首先通过IP协议来判断两台主机是否在同一个子网中
2.如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包
3.如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由
4.最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方

IP数据包
 1.在网络层被包装的数据包就叫IP数据包，IPv4数据包的结构如下图所示
 a.IP数据包由首部和数据两部分组成，首部长度为20个字节，主要包含了目标IP地址和源IP地址
 b.数据部分的最大长度为65515字节，理论上一个IP数据包的总长度可以达到65535个字节
 c.而以太网数据包的最大长度是1500个字符，如果超过这个大小，就需要对IP数据包进行分割，分成多帧发送

 */
/*
1.链路层定义了主机的身份，即MAC地址， 而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。
2.但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包
传输层:定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。


 UDP协议:
1.因此传输层引入了UDP协议来解决这个问题，为了给每个应用程序标识身份，UDP协议定义了端口
2.同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息
3.UDP数据包:由首部和数据两部分组成
    a.首部长度为8个字节，主要包括源端口和目标端口；
    b.数据最大为65527个字节，整个数据包的长度最大可达到65535个字节
4.UDP协议比较简单，实现容易，但它没有确认机制， 数据包一旦发出，无法知道对方是否收到，因此可靠性较差

 TCP协议:
 1.TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。
 2.简单来说TCP就是有确认机制的UDP协议，
 3.每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包

TCP协议的三次握手
1.为了保证传输的可靠性，TCP 协议在 UDP 基础之上建立了三次对话的确认机制，也就是说，在正式收发数据前，必须和对方建立可靠的连接
 主机A：我想发数据给你，可以么？
 主机B：可以，你什么时候发？
 主机A：我马上发，你接着！

TCP 数据包:由首部和数据两部分组成
 a.
 b.
 c.TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过IP数据包的长度，以确保单个 TCP 数据包不必再分割
 */

/*应用层:定义数据格式并按照对应的格式解读数据。
1.有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流
2.应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等,便于被程序识别
 */

/*
链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；
网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；
传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；
应用层：定义数据格式，并按照对应的格式解读数据

当你输入一个网址并按下回车键的时候，
1.首先应用层协议对该请求包做了格式定义；
2.紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；
3.然后网络协议加上了双方的IP地址，确认了双方的网络位置；
4.最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机
5.目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理
*/
