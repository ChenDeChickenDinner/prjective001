//
//  MemoryManagement.h
//  MRC
//
//  Created by xs on 2021/3/19.
//

#import <Foundation/Foundation.h>


内存分布
 2.代码段（__TEXT）:编译之后的代码
 3.数据段（__DATA）
 1.字符串常量 ：比如NSString *str = @"123"
 2.已初始化数据 ：已初始化的全局变量、静态变量等
 3.未初始化数据 ：未初始化的全局变量、静态变量等
 4.栈区：编译器自动分配，由系统管理，在不需要的时候自动清除。
        局部变量、函数参数存储在这里。栈区的内存地址一般是0x7开头
 5.堆区 ：那些由new，alloc、block copy创建的对象存储在这里，是由开发者管理的，需要告诉系统什么时候释放内存；
         堆区的内存地址一般是0x6开头


核心技术:引用计数式
1.当一个对象创建并在堆区申请内存时，对象的引用计数为1；
2.当对象的引用计数为0时，runtime会主动调用对象的dealloc


引用计数存储位置：
a:存在isa中

b:存在 SideTable中
1.系统中维护了一个全局的SideTables，这是一个SideTable的集合。
 为什么用多个SideTable？ 如果只有一个table，意味着内存中分配的所有对象都要在一个表中操作，因为多个线程可能同时操作这个表，所以就要对这个表加锁，如果并发操作这个表的线程有成千上万个，就会产生效率问题。所以系统引入了分离锁这样一个技术方案，把大表拆成多个小表来进行操作，分别对小表加锁，从而提升效率

2.SideTable在OC中扮演这一个很重要的角色,在runtime中，通过SideTable来管理对象的引用计数以及weak引用。

c:当引用计数存储到一定值是，并不会再存储到Nonpointer_isa的位域的extra_rc中，而是会存储到SideTables 散列表中


struct SideTable {

    自旋锁，用于上锁/解锁 SideTable。
    spinlock_t slock;

    用来存储OC对象的引用计数的 hash表(仅在未开启isa优化或在isa优化情况下isa_t的引用计数溢出时才会用到)
    RefcountMap refcnts;

    存储对象弱引用指针的hash表。是OC中weak功能实现的核心数据结构。
    weak_table_t weak_table;
}


引用计数式api

A:方法含义
0.retainCount方法返回该对象的引用计数值
1.调用alloc、new、copy、mutableCopy名称开头的方法创建的对象，该对象的引用计数加1。
2.调用retain方法时，该对象的引用计数加1。
3.调用release方法时，该对象的引用计数减1。
4.autorelease方法不改变该对象的引用计数器的值，只是将对象添加到自动释放池中。
5.对象计数器为0被回收后要立马赋值为nil废弃对象(以免访问坏内存-野指针问题)


空指针
1.空指针常量
1.1:一个表示0值的整数常量，叫做空指针常量【 0、0L 、3 - 3以及 (void)0, 等都是空指针常量】
1.2.至于系统选取哪种形式作为空指针常量使用，则是实现相关的【一般的 C 系统选择 (void*)0 或者 0 的居多（也有个别的选择 0L）】

2.空指针
2.1:如果一个 空指针常量 赋给了一个有类型的指针变量，那么这个指针就叫空指针。
2.2:空指针不指向任何对象 与函数，其值 = 0;

3.NUll
C中对NULL的预定义有两个：
　　#define NULL 0  ---->就是数值0
　　#define NULL ((void *)0)---->指向0的指针
1.NULL和0的值都是一样的，但是为了目的和用途及容易识别的原因，NULL用于指针和对象，0用于数值
2.当常量0处于应该作为指针使用的上下文中时，它就作为空指针使用；在指针上下文中“值为0的整型常量表达式”在编译时转换为空指针 int * p = 0;


野指针:
1.C语言中的野指针指的是定义了一个指针但是没有初始化, 导致指针中存储的是垃圾值, 指向内存中的任意地址.
2.OC中的野指：指针有值，但指向的对象已经被回收
 a.如果继续使用这个指针进行操作会造成怀内存访问，直接崩溃
 b.所以当一个指针成为野指针了，需要对这个指针进行 nil 操作，以免后续的使用造成崩溃

僵尸对象:
指的是内存中的对象已经被释放, 但还没有被CPU给分配出去.


内存泄漏：
指的是一个应该被回收的对象, 没有得到及时的回收. 这样的对象会一直存在于内存中 直到程序结束. 这样的结果会导致内存的泄漏.
